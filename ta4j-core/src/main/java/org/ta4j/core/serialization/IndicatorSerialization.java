/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2017-2025 Ta4j Organization & respective
 * authors (see AUTHORS)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package org.ta4j.core.serialization;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.math.BigDecimal;
import java.net.JarURLConnection;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.jar.JarFile;
import java.util.stream.Stream;

import org.ta4j.core.BarSeries;
import org.ta4j.core.Indicator;
import org.ta4j.core.indicators.AbstractIndicator;
import org.ta4j.core.indicators.CachedIndicator;
import org.ta4j.core.indicators.RecursiveCachedIndicator;
import org.ta4j.core.num.Num;

/**
 * Serializes and deserializes {@link Indicator} instances into structured
 * {@link ComponentDescriptor} payloads.
 *
 * @since 0.19
 */
public final class IndicatorSerialization {

    private static final String INDICATOR_PACKAGE = "org.ta4j.core.indicators";
    private static final String PACKAGE_PATH = INDICATOR_PACKAGE.replace('.', '/');
    private static final ConcurrentMap<String, List<Class<?>>> INDICATOR_TYPES = new ConcurrentHashMap<>();
    private static final Set<String> IGNORED_CHILD_INDICATORS = Set
            .of("org.ta4j.core.indicators.helpers.RunningTotalIndicator");
    private static final Object NO_PARAMETER_VALUE = new Object();

    private IndicatorSerialization() {
    }

    /**
     * Serializes an {@link Indicator} to a JSON payload.
     *
     * @param indicator indicator instance
     * @return JSON representation
     */
    public static String toJson(Indicator<?> indicator) {
        return ComponentSerialization.toJson(describe(indicator));
    }

    /**
     * Converts an {@link Indicator} into a {@link ComponentDescriptor} hierarchy.
     *
     * @param indicator indicator instance
     * @return descriptor representing the indicator
     */
    public static ComponentDescriptor describe(Indicator<?> indicator) {
        Objects.requireNonNull(indicator, "indicator");
        IdentityHashMap<Indicator<?>, ComponentDescriptor> visited = new IdentityHashMap<>();
        return describe(indicator, visited);
    }

    /**
     * Rebuilds an indicator from a JSON payload.
     *
     * @param series bar series to attach to the indicator
     * @param json   JSON representation generated by {@link #toJson(Indicator)}
     * @return reconstructed indicator
     */
    public static Indicator<?> fromJson(BarSeries series, String json) {
        ComponentDescriptor descriptor = ComponentSerialization.parse(json);
        return fromDescriptor(series, descriptor);
    }

    /**
     * Rebuilds an indicator from a descriptor tree.
     *
     * @param series     bar series to attach to the indicator
     * @param descriptor descriptor describing the indicator
     * @return reconstructed indicator
     */
    public static Indicator<?> fromDescriptor(BarSeries series, ComponentDescriptor descriptor) {
        Objects.requireNonNull(series, "series");
        Objects.requireNonNull(descriptor, "descriptor");
        return instantiate(series, descriptor);
    }

    private static ComponentDescriptor describe(Indicator<?> indicator,
            IdentityHashMap<Indicator<?>, ComponentDescriptor> visited) {
        ComponentDescriptor cached = visited.get(indicator);
        if (cached != null) {
            return cached;
        }

        ComponentDescriptor.Builder builder = ComponentDescriptor.builder()
                .withType(indicator.getClass().getSimpleName());

        Map<String, Object> parameters = extractNumericParameters(indicator);
        if (!parameters.isEmpty()) {
            builder.withParameters(parameters);
        }

        List<ChildView> childIndicators = extractChildIndicators(indicator);
        for (ChildView child : childIndicators) {
            ComponentDescriptor childDescriptor = describe(child.indicator(), visited);
            builder.addChild(applyLabel(childDescriptor, child.label()));
        }

        ComponentDescriptor descriptor = builder.build();
        visited.put(indicator, descriptor);
        return descriptor;
    }

    private static ComponentDescriptor applyLabel(ComponentDescriptor descriptor, String label) {
        if (label == null || label.isBlank()) {
            return descriptor;
        }
        ComponentDescriptor.Builder builder = ComponentDescriptor.builder()
                .withType(descriptor.getType())
                .withLabel(label);
        if (!descriptor.getParameters().isEmpty()) {
            builder.withParameters(descriptor.getParameters());
        }
        for (ComponentDescriptor child : descriptor.getChildren()) {
            builder.addChild(child);
        }
        return builder.build();
    }

    private static Indicator<?> instantiate(BarSeries series, ComponentDescriptor descriptor) {
        Class<?> type = resolveIndicatorClass(descriptor.getType());
        if (type == null) {
            throw new IllegalArgumentException("Unknown indicator type: " + descriptor.getType());
        }
        List<Indicator<?>> children = new ArrayList<>();
        for (ComponentDescriptor childDescriptor : descriptor.getChildren()) {
            children.add(instantiate(series, childDescriptor));
        }

        Map<String, Object> parameters = descriptor.getParameters();
        Object instance = tryInstantiate(type, series, children, parameters);
        if (!(instance instanceof Indicator<?> indicator)) {
            throw new IllegalStateException("Constructed type does not implement Indicator: " + type.getName());
        }
        return indicator;
    }

    private static Object tryInstantiate(Class<?> type, BarSeries series, List<Indicator<?>> children,
            Map<String, Object> parameters) {
        Constructor<?>[] constructors = type.getDeclaredConstructors();
        Arrays.sort(constructors,
                (left, right) -> Integer.compare(right.getParameterCount(), left.getParameterCount()));
        Map<String, Object> parameterValues = parameters == null ? Map.of() : new LinkedHashMap<>(parameters);
        for (Constructor<?> constructor : constructors) {
            if (Modifier.isPrivate(constructor.getModifiers())) {
                continue;
            }
            Optional<Object> instance = tryInvoke(constructor, series, children, parameterValues);
            if (instance.isPresent()) {
                return instance.get();
            }
        }
        throw new IllegalStateException("Unable to instantiate indicator: " + type.getName());
    }

    private static Optional<Object> tryInvoke(Constructor<?> constructor, BarSeries series, List<Indicator<?>> children,
            Map<String, Object> parameters) {
        Class<?>[] parameterTypes = constructor.getParameterTypes();
        Parameter[] parameterMetadata = constructor.getParameters();
        Object[] args = new Object[parameterTypes.length];
        int childIndex = 0;
        LinkedHashMap<String, Object> parameterPool = parameters == null ? new LinkedHashMap<>()
                : new LinkedHashMap<>(parameters);
        List<NumericParameterRequest> numericRequests = new ArrayList<>();

        for (int i = 0; i < parameterTypes.length; i++) {
            Class<?> parameterType = parameterTypes[i];
            Parameter parameter = parameterMetadata.length > i ? parameterMetadata[i] : null;
            if (BarSeries.class.isAssignableFrom(parameterType)) {
                args[i] = series;
            } else if (Indicator.class.isAssignableFrom(parameterType)) {
                if (childIndex >= children.size()) {
                    return Optional.empty();
                }
                Indicator<?> child = children.get(childIndex++);
                if (!parameterType.isInstance(child)) {
                    return Optional.empty();
                }
                args[i] = child;
            } else if (parameterType.isArray() && Indicator.class.isAssignableFrom(parameterType.getComponentType())) {
                Indicator<?>[] remaining = children.subList(childIndex, children.size()).toArray(Indicator[]::new);
                for (Indicator<?> child : remaining) {
                    if (!parameterType.getComponentType().isInstance(child)) {
                        return Optional.empty();
                    }
                }
                args[i] = remaining;
                childIndex = children.size();
            } else if (List.class.isAssignableFrom(parameterType)) {
                List<Indicator<?>> remaining = new ArrayList<>(children.subList(childIndex, children.size()));
                args[i] = remaining;
                childIndex = children.size();
            } else {
                numericRequests.add(new NumericParameterRequest(i, parameterType, parameter));
            }
        }

        Map<Integer, Object> resolvedValues = new HashMap<>();
        for (NumericParameterRequest request : numericRequests) {
            Object value = extractNamedParameterValue(request.parameter(), parameterPool);
            if (value != NO_PARAMETER_VALUE) {
                resolvedValues.put(request.index(), value);
            }
        }

        for (NumericParameterRequest request : numericRequests) {
            if (resolvedValues.containsKey(request.index())) {
                continue;
            }
            Object value = pollNextParameterValue(parameterPool);
            if (value == NO_PARAMETER_VALUE) {
                return Optional.empty();
            }
            resolvedValues.put(request.index(), value);
        }

        for (NumericParameterRequest request : numericRequests) {
            Object value = resolvedValues.get(request.index());
            Object converted = convertNumericValue(value, request.type(), series);
            if (converted == null) {
                return Optional.empty();
            }
            args[request.index()] = converted;
        }

        try {
            constructor.setAccessible(true);
            return Optional.of(constructor.newInstance(args));
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
            return Optional.empty();
        }
    }

    private static Object extractNamedParameterValue(Parameter parameter, LinkedHashMap<String, Object> parameters) {
        if (parameters == null || parameters.isEmpty() || parameter == null || !parameter.isNamePresent()) {
            return NO_PARAMETER_VALUE;
        }
        String name = parameter.getName();
        if (parameters.containsKey(name)) {
            return parameters.remove(name);
        }
        Iterator<Map.Entry<String, Object>> iterator = parameters.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<String, Object> entry = iterator.next();
            if (entry.getKey().equalsIgnoreCase(name)) {
                iterator.remove();
                return entry.getValue();
            }
        }
        String normalizedName = normalizeName(name);
        if (normalizedName.isEmpty()) {
            return NO_PARAMETER_VALUE;
        }
        iterator = parameters.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<String, Object> entry = iterator.next();
            String normalizedKey = normalizeName(entry.getKey());
            if (normalizedKey.startsWith(normalizedName)) {
                iterator.remove();
                return entry.getValue();
            }
        }
        return NO_PARAMETER_VALUE;
    }

    private static Object pollNextParameterValue(LinkedHashMap<String, Object> parameters) {
        if (parameters == null || parameters.isEmpty()) {
            return NO_PARAMETER_VALUE;
        }
        Iterator<Map.Entry<String, Object>> iterator = parameters.entrySet().iterator();
        if (!iterator.hasNext()) {
            return NO_PARAMETER_VALUE;
        }
        Map.Entry<String, Object> entry = iterator.next();
        iterator.remove();
        return entry.getValue();
    }

    private static String normalizeName(String name) {
        StringBuilder builder = new StringBuilder(name.length());
        for (int i = 0; i < name.length(); i++) {
            char ch = name.charAt(i);
            if (Character.isLetterOrDigit(ch)) {
                builder.append(Character.toLowerCase(ch));
            }
        }
        return builder.toString();
    }

    private static Object convertNumericValue(Object value, Class<?> targetType, BarSeries series) {
        if (value == null) {
            return null;
        }
        if (targetType == String.class) {
            return value.toString();
        }
        if (Num.class.isAssignableFrom(targetType)) {
            return series.numFactory().numOf(value.toString());
        }
        Number coerced = coerceNumber(value);
        if (targetType == int.class || targetType == Integer.class) {
            return coerced.intValue();
        }
        if (targetType == long.class || targetType == Long.class) {
            return coerced.longValue();
        }
        if (targetType == double.class || targetType == Double.class) {
            return coerced.doubleValue();
        }
        if (targetType == float.class || targetType == Float.class) {
            return coerced.floatValue();
        }
        if (targetType == short.class || targetType == Short.class) {
            return coerced.shortValue();
        }
        if (targetType == byte.class || targetType == Byte.class) {
            return coerced.byteValue();
        }
        if (Number.class.isAssignableFrom(targetType)) {
            if (targetType.isInstance(coerced)) {
                return coerced;
            }
            if (targetType == BigDecimal.class) {
                return new BigDecimal(coerced.toString());
            }
        }
        return null;
    }

    private static Number coerceNumber(Object value) {
        if (value instanceof Number number) {
            return number;
        }
        return new BigDecimal(value.toString());
    }

    private static Map<String, Object> extractNumericParameters(Indicator<?> indicator) {
        Map<String, Object> parameters = new LinkedHashMap<>();
        for (FieldView field : collectFields(indicator)) {
            if (!field.isNumeric()) {
                continue;
            }
            Object formatted = formatNumericValue(field.value());
            if (formatted != null) {
                parameters.put(field.label(), formatted);
            }
        }
        return parameters;
    }

    private static List<ChildView> extractChildIndicators(Indicator<?> indicator) {
        List<ChildView> children = new ArrayList<>();
        for (FieldView field : collectFields(indicator)) {
            if (!field.isIndicator()) {
                continue;
            }
            Object value = field.value();
            if (value instanceof Indicator<?> child && child != indicator) {
                if (!shouldIgnoreChild(child)) {
                    children.add(new ChildView(field.label(), child));
                }
            } else if (value instanceof List<?> list) {
                int index = 0;
                for (Object element : list) {
                    if (element instanceof Indicator<?> child) {
                        if (!shouldIgnoreChild(child)) {
                            children.add(new ChildView(field.label() + "[" + index + "]", child));
                        }
                        index++;
                    }
                }
            } else if (value != null && value.getClass().isArray()
                    && Indicator.class.isAssignableFrom(value.getClass().getComponentType())) {
                Indicator<?>[] array = (Indicator<?>[]) value;
                for (int i = 0; i < array.length; i++) {
                    Indicator<?> child = array[i];
                    if (child != null && !shouldIgnoreChild(child)) {
                        children.add(new ChildView(field.label() + "[" + i + "]", child));
                    }
                }
            }
        }
        return children;
    }

    private static boolean shouldIgnoreChild(Indicator<?> indicator) {
        return IGNORED_CHILD_INDICATORS.contains(indicator.getClass().getName());
    }

    private static Object formatNumericValue(Object value) {
        if (value == null) {
            return null;
        }
        if (value instanceof Num num) {
            return trimDecimal(num.getDelegate().toString());
        }
        if (value instanceof BigDecimal decimal) {
            return trimDecimal(decimal.toString());
        }
        if (value instanceof Double || value instanceof Float) {
            BigDecimal decimal = BigDecimal.valueOf(((Number) value).doubleValue());
            return trimDecimal(decimal.toPlainString());
        }
        if (value instanceof Number) {
            return value;
        }
        return null;
    }

    private static String trimDecimal(String value) {
        try {
            BigDecimal decimal = new BigDecimal(value);
            decimal = decimal.stripTrailingZeros();
            if (decimal.scale() < 0) {
                decimal = decimal.setScale(0);
            }
            return decimal.toPlainString();
        } catch (NumberFormatException e) {
            return value;
        }
    }

    private static List<FieldView> collectFields(Indicator<?> indicator) {
        List<FieldView> fields = new ArrayList<>();
        Class<?> type = indicator.getClass();
        while (type != null && type != Object.class && type != AbstractIndicator.class && type != CachedIndicator.class
                && type != RecursiveCachedIndicator.class) {
            Field[] declared = type.getDeclaredFields();
            for (Field field : declared) {
                if (Modifier.isStatic(field.getModifiers()) || field.isSynthetic()) {
                    continue;
                }
                field.setAccessible(true);
                try {
                    Object value = field.get(indicator);
                    fields.add(new FieldView(field.getName(), value, field.getType()));
                } catch (IllegalAccessException ignored) {
                    // Ignore inaccessible field
                }
            }
            type = type.getSuperclass();
        }
        return fields;
    }

    private static Class<?> resolveIndicatorClass(String simpleName) {
        if (simpleName == null || simpleName.isBlank()) {
            return null;
        }
        ensureTypeCache();
        List<Class<?>> types = INDICATOR_TYPES.get(simpleName);
        if (types == null || types.isEmpty()) {
            return null;
        }
        if (types.size() > 1) {
            throw new IllegalStateException("Multiple indicator classes share the simple name: " + simpleName);
        }
        return types.getFirst();
    }

    private static void ensureTypeCache() {
        if (!INDICATOR_TYPES.isEmpty()) {
            return;
        }
        synchronized (INDICATOR_TYPES) {
            if (!INDICATOR_TYPES.isEmpty()) {
                return;
            }
            try {
                ClassLoader loader = Thread.currentThread().getContextClassLoader();
                if (loader == null) {
                    loader = IndicatorSerialization.class.getClassLoader();
                }
                if (loader == null) {
                    return;
                }
                Enumeration<URL> resources = loader.getResources(PACKAGE_PATH);
                while (resources.hasMoreElements()) {
                    URL resource = resources.nextElement();
                    scanResource(loader, resource);
                }
            } catch (IOException e) {
                throw new IllegalStateException("Failed to scan indicator classes", e);
            }
        }
    }

    private static void scanResource(ClassLoader loader, URL resource) {
        String protocol = resource.getProtocol();
        if ("file".equals(protocol)) {
            try {
                Path root = Paths.get(resource.toURI());
                scanDirectory(loader, root, INDICATOR_PACKAGE);
            } catch (IOException | URISyntaxException e) {
                throw new IllegalStateException("Failed to scan indicator directory", e);
            }
        } else if ("jar".equals(protocol)) {
            try {
                JarURLConnection connection = (JarURLConnection) resource.openConnection();
                try (JarFile jarFile = connection.getJarFile()) {
                    scanJar(loader, jarFile, PACKAGE_PATH);
                }
            } catch (IOException e) {
                throw new IllegalStateException("Failed to scan indicator jar", e);
            }
        }
    }

    private static void scanDirectory(ClassLoader loader, Path root, String packageName) throws IOException {
        try (Stream<Path> paths = Files.walk(root)) {
            paths.filter(path -> Files.isRegularFile(path) && path.toString().endsWith(".class")).forEach(path -> {
                Path relative = root.relativize(path);
                String className = packageName + '.' + toClassName(relative);
                registerIfIndicator(loader, className);
            });
        }
    }

    private static void scanJar(ClassLoader loader, JarFile jarFile, String packagePath) {
        jarFile.stream()
                .filter(entry -> !entry.isDirectory() && entry.getName().startsWith(packagePath)
                        && entry.getName().endsWith(".class"))
                .forEach(entry -> {
                    String className = entry.getName().replace('/', '.').replaceAll("\\.class$", "");
                    registerIfIndicator(loader, className);
                });
    }

    private static String toClassName(Path relative) {
        String joined = relative.toString().replace('/', '.').replace('\\', '.');
        return joined.substring(0, joined.length() - ".class".length());
    }

    private static void registerIfIndicator(ClassLoader loader, String className) {
        if (className.contains("$")) {
            return;
        }
        try {
            Class<?> type = Class.forName(className, false, loader);
            if (!Indicator.class.isAssignableFrom(type) || Modifier.isAbstract(type.getModifiers())) {
                return;
            }
            INDICATOR_TYPES.compute(type.getSimpleName(), (key, existing) -> {
                List<Class<?>> list = existing == null ? new ArrayList<>() : new ArrayList<>(existing);
                list.add(type);
                return list;
            });
        } catch (ClassNotFoundException ignored) {
            // Ignore classes that cannot be loaded
        }
    }

    private record FieldView(String label, Object value, Class<?> type) {

        boolean isIndicator() {
            if (value instanceof Indicator<?> || value instanceof List<?>) {
                return true;
            }
            if (value != null && value.getClass().isArray()) {
                return Indicator.class.isAssignableFrom(value.getClass().getComponentType());
            }
            return Indicator.class.isAssignableFrom(type);
        }

        boolean isNumeric() {
            if (value instanceof Num) {
                return true;
            }
            if (type.isPrimitive()) {
                return type != boolean.class && type != char.class;
            }
            return Number.class.isAssignableFrom(type) || value instanceof Number;
        }
    }

    private record ChildView(String label, Indicator<?> indicator) {
    }

    private record NumericParameterRequest(int index, Class<?> type, Parameter parameter) {
    }
}
