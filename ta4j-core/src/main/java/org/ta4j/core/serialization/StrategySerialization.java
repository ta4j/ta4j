/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2017-2025 Ta4j Organization & respective
 * authors (see AUTHORS)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package org.ta4j.core.serialization;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import org.ta4j.core.BarSeries;
import org.ta4j.core.BaseStrategy;
import org.ta4j.core.Rule;
import org.ta4j.core.Strategy;
import org.ta4j.core.strategy.named.NamedStrategy;

/**
 * Serializes and deserializes {@link Strategy} instances into structured
 * {@link ComponentDescriptor} payloads.
 *
 * @since 0.19
 */
public final class StrategySerialization {

    private static final String ENTRY_LABEL = "entry";
    private static final String EXIT_LABEL = "exit";
    private static final String STRATEGY_PACKAGE = "org.ta4j.core";

    private StrategySerialization() {
    }

    /**
     * Serializes a {@link Strategy} to a JSON payload.
     *
     * @param strategy strategy instance
     * @return JSON representation
     */
    public static String toJson(Strategy strategy) {
        return ComponentSerialization.toJson(describe(strategy));
    }

    /**
     * Converts a {@link Strategy} into a {@link ComponentDescriptor} hierarchy.
     *
     * @param strategy strategy instance
     * @return descriptor representing the strategy
     */
    public static ComponentDescriptor describe(Strategy strategy) {
        Objects.requireNonNull(strategy, "strategy");

        if (strategy instanceof NamedStrategy) {
            return strategy.toDescriptor();
        }

        ComponentDescriptor entryDescriptor = RuleSerialization.describe(strategy.getEntryRule());
        ComponentDescriptor exitDescriptor = RuleSerialization.describe(strategy.getExitRule());

        ComponentDescriptor.Builder builder = ComponentDescriptor.builder()
                .withType(strategy.getClass().getSimpleName());

        String name = strategy.getName();
        if (name != null && !name.isBlank()) {
            builder.withLabel(name);
        }

        Map<String, Object> parameters = new HashMap<>();
        parameters.put("unstableBars", strategy.getUnstableBars());
        builder.withParameters(parameters);

        if (entryDescriptor != null) {
            builder.addChild(applyLabel(entryDescriptor, ENTRY_LABEL));
        }
        if (exitDescriptor != null) {
            builder.addChild(applyLabel(exitDescriptor, EXIT_LABEL));
        }

        return builder.build();
    }

    /**
     * Rebuilds a strategy from a JSON payload.
     *
     * @param series bar series to attach to the strategy
     * @param json   JSON representation generated by {@link #toJson(Strategy)}
     * @return reconstructed strategy
     */
    public static Strategy fromJson(BarSeries series, String json) {
        ComponentDescriptor descriptor = ComponentSerialization.parse(json);
        return fromDescriptor(series, descriptor);
    }

    /**
     * Rebuilds a strategy from a descriptor tree.
     *
     * @param series     bar series to attach to the strategy
     * @param descriptor descriptor describing the strategy
     * @return reconstructed strategy
     */
    public static Strategy fromDescriptor(BarSeries series, ComponentDescriptor descriptor) {
        Objects.requireNonNull(series, "series");
        Objects.requireNonNull(descriptor, "descriptor");

        Class<? extends Strategy> strategyType = resolveStrategyClass(descriptor.getType());
        if (NamedStrategy.class.isAssignableFrom(strategyType)) {
            return instantiateNamedStrategy(series, descriptor, strategyType);
        }

        Rule entryRule = instantiateRule(series, extractChild(descriptor, ENTRY_LABEL));
        Rule exitRule = instantiateRule(series, extractChild(descriptor, EXIT_LABEL));

        String name = descriptor.getLabel();
        int unstableBars = extractUnstableBars(descriptor.getParameters().get("unstableBars"));

        Strategy strategy = instantiateStrategy(strategyType, name, entryRule, exitRule, unstableBars);
        strategy.setUnstableBars(unstableBars);
        return strategy;
    }

    private static ComponentDescriptor applyLabel(ComponentDescriptor descriptor, String label) {
        if (descriptor == null) {
            return null;
        }
        ComponentDescriptor.Builder builder = ComponentDescriptor.builder()
                .withType(descriptor.getType())
                .withLabel(label);
        if (!descriptor.getParameters().isEmpty()) {
            builder.withParameters(descriptor.getParameters());
        }
        for (ComponentDescriptor child : descriptor.getChildren()) {
            builder.addChild(child);
        }
        return builder.build();
    }

    private static ComponentDescriptor extractChild(ComponentDescriptor descriptor, String label) {
        for (ComponentDescriptor child : descriptor.getChildren()) {
            if (label.equals(child.getLabel())) {
                return cloneWithoutLabel(child);
            }
        }
        throw new IllegalArgumentException("Missing strategy " + label + " rule descriptor");
    }

    private static ComponentDescriptor cloneWithoutLabel(ComponentDescriptor descriptor) {
        if (descriptor == null) {
            return null;
        }
        ComponentDescriptor.Builder builder = ComponentDescriptor.builder().withType(descriptor.getType());
        if (!descriptor.getParameters().isEmpty()) {
            builder.withParameters(descriptor.getParameters());
        }
        for (ComponentDescriptor child : descriptor.getChildren()) {
            builder.addChild(child);
        }
        return builder.build();
    }

    private static int extractUnstableBars(Object value) {
        if (value == null) {
            return 0;
        }
        if (value instanceof Number) {
            return ((Number) value).intValue();
        }
        return Integer.parseInt(String.valueOf(value));
    }

    private static Rule instantiateRule(BarSeries series, ComponentDescriptor descriptor) {
        if (descriptor == null) {
            throw new IllegalArgumentException("Rule descriptor cannot be null");
        }

        // Check if this is a rule by type name (contains "Rule")
        String type = descriptor.getType();
        if (type != null && type.contains("Rule")) {
            return RuleSerialization.fromDescriptor(series, descriptor);
        }

        // Legacy check for __args (for backwards compatibility)
        if (descriptor.getParameters().containsKey("__args")) {
            return RuleSerialization.fromDescriptor(series, descriptor);
        }

        if (type == null || type.isBlank()) {
            throw new IllegalArgumentException("Rule descriptor missing type: " + descriptor);
        }
        Class<?> clazz = resolveRuleClass(type);
        if (!Rule.class.isAssignableFrom(clazz)) {
            throw new IllegalArgumentException("Descriptor type does not implement Rule: " + type);
        }
        @SuppressWarnings("unchecked")
        Class<? extends Rule> ruleType = (Class<? extends Rule>) clazz;

        Optional<Rule> instance = invokeFactory(ruleType, series, descriptor);
        if (instance.isPresent()) {
            return instance.get();
        }

        if (!descriptor.getChildren().isEmpty()) {
            List<Rule> children = new ArrayList<>(descriptor.getChildren().size());
            for (ComponentDescriptor child : descriptor.getChildren()) {
                children.add(instantiateRule(series, child));
            }
            Optional<Rule> composite = tryCompositeConstructor(ruleType, children);
            if (composite.isPresent()) {
                return composite.get();
            }
        }

        Optional<Rule> constructed = tryDescriptorConstructor(ruleType, series, descriptor);
        if (constructed.isPresent()) {
            return constructed.get();
        }

        throw new IllegalArgumentException("Unable to instantiate rule type: " + type);
    }

    private static Optional<Rule> invokeFactory(Class<? extends Rule> ruleType, BarSeries series,
            ComponentDescriptor descriptor) {
        try {
            Method factory = ruleType.getDeclaredMethod("fromDescriptor", BarSeries.class, ComponentDescriptor.class);
            factory.setAccessible(true);
            return Optional.of((Rule) factory.invoke(null, series, descriptor));
        } catch (NoSuchMethodException ex) {
            // ignore and try the next option
        } catch (IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to invoke factory on rule type: " + ruleType.getName(), ex);
        }

        try {
            Method factory = ruleType.getDeclaredMethod("fromDescriptor", ComponentDescriptor.class);
            factory.setAccessible(true);
            return Optional.of((Rule) factory.invoke(null, descriptor));
        } catch (NoSuchMethodException ex) {
            // ignore and try next
        } catch (IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to invoke factory on rule type: " + ruleType.getName(), ex);
        }

        return Optional.empty();
    }

    private static Optional<Rule> tryCompositeConstructor(Class<? extends Rule> ruleType, List<Rule> children) {
        Constructor<?>[] constructors = ruleType.getDeclaredConstructors();
        for (Constructor<?> constructor : constructors) {
            Class<?>[] parameterTypes = constructor.getParameterTypes();
            if (parameterTypes.length != children.size()) {
                continue;
            }
            boolean matches = true;
            for (Class<?> parameterType : parameterTypes) {
                if (!Rule.class.isAssignableFrom(parameterType)) {
                    matches = false;
                    break;
                }
            }
            if (!matches) {
                continue;
            }
            try {
                constructor.setAccessible(true);
                return Optional.of((Rule) constructor.newInstance(children.toArray()));
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                throw new IllegalStateException("Failed to construct composite rule: " + ruleType.getName(), ex);
            }
        }
        return Optional.empty();
    }

    private static Optional<Rule> tryDescriptorConstructor(Class<? extends Rule> ruleType, BarSeries series,
            ComponentDescriptor descriptor) {
        try {
            Constructor<? extends Rule> constructor = ruleType.getDeclaredConstructor(BarSeries.class,
                    ComponentDescriptor.class);
            constructor.setAccessible(true);
            return Optional.of(constructor.newInstance(series, descriptor));
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct rule: " + ruleType.getName(), ex);
        }

        try {
            Constructor<? extends Rule> constructor = ruleType.getDeclaredConstructor(ComponentDescriptor.class);
            constructor.setAccessible(true);
            return Optional.of(constructor.newInstance(descriptor));
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct rule: " + ruleType.getName(), ex);
        }

        try {
            Constructor<? extends Rule> constructor = ruleType.getDeclaredConstructor();
            constructor.setAccessible(true);
            return Optional.of(constructor.newInstance());
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct rule: " + ruleType.getName(), ex);
        }

        return Optional.empty();
    }

    @SuppressWarnings("unchecked")
    private static Class<? extends Rule> resolveRuleClass(String type) {
        try {
            return (Class<? extends Rule>) Class.forName(type);
        } catch (ClassNotFoundException ex) {
            // try ta4j core rules package
        }
        try {
            return (Class<? extends Rule>) Class.forName("org.ta4j.core.rules." + type);
        } catch (ClassNotFoundException ex) {
            throw new IllegalArgumentException("Unknown rule type: " + type, ex);
        }
    }

    @SuppressWarnings("unchecked")
    private static Class<? extends Strategy> resolveStrategyClass(String type) {
        if (type == null || type.isBlank()) {
            return BaseStrategy.class;
        }
        try {
            Class<?> clazz = Class.forName(type);
            if (Strategy.class.isAssignableFrom(clazz)) {
                return (Class<? extends Strategy>) clazz;
            }
        } catch (ClassNotFoundException ex) {
            // ignore and try package-local lookup
        }
        try {
            Class<?> clazz = Class.forName(STRATEGY_PACKAGE + '.' + type);
            if (Strategy.class.isAssignableFrom(clazz)) {
                return (Class<? extends Strategy>) clazz;
            }
        } catch (ClassNotFoundException ex) {
            // ignore and fall back to BaseStrategy
        }
        return BaseStrategy.class;
    }

    private static Strategy instantiateStrategy(Class<? extends Strategy> strategyType, String name, Rule entryRule,
            Rule exitRule, int unstableBars) {
        try {
            Constructor<? extends Strategy> constructor = strategyType.getDeclaredConstructor(String.class, Rule.class,
                    Rule.class, int.class);
            constructor.setAccessible(true);
            return constructor.newInstance(name, entryRule, exitRule, unstableBars);
        } catch (NoSuchMethodException ex) {
            // ignore and try the next options
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct strategy: " + strategyType.getName(), ex);
        }

        try {
            Constructor<? extends Strategy> constructor = strategyType.getDeclaredConstructor(String.class, Rule.class,
                    Rule.class);
            constructor.setAccessible(true);
            Strategy strategy = constructor.newInstance(name, entryRule, exitRule);
            strategy.setUnstableBars(unstableBars);
            return strategy;
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct strategy: " + strategyType.getName(), ex);
        }

        try {
            Constructor<? extends Strategy> constructor = strategyType.getDeclaredConstructor(Rule.class, Rule.class,
                    int.class);
            constructor.setAccessible(true);
            Strategy strategy = constructor.newInstance(entryRule, exitRule, unstableBars);
            return strategy;
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct strategy: " + strategyType.getName(), ex);
        }

        try {
            Constructor<? extends Strategy> constructor = strategyType.getDeclaredConstructor(Rule.class, Rule.class);
            constructor.setAccessible(true);
            Strategy strategy = constructor.newInstance(entryRule, exitRule);
            strategy.setUnstableBars(unstableBars);
            return strategy;
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct strategy: " + strategyType.getName(), ex);
        }

        if (!strategyType.equals(BaseStrategy.class)) {
            return new BaseStrategy(name, entryRule, exitRule, unstableBars);
        }
        throw new IllegalStateException("No suitable constructor found for strategy type: " + strategyType.getName());
    }

    private static Strategy instantiateNamedStrategy(BarSeries series, ComponentDescriptor descriptor,
            Class<? extends Strategy> strategyType) {
        String label = descriptor.getLabel();
        if (label == null || label.isBlank()) {
            throw new IllegalArgumentException("Named strategy descriptor missing label");
        }

        String simpleName = strategyType.getSimpleName();
        if (!label.startsWith(simpleName)) {
            throw new IllegalArgumentException(
                    "Descriptor label does not match strategy type: " + label + " vs " + simpleName);
        }

        List<String> encodedTokens = parseLabelTokens(label, simpleName);
        if (encodedTokens.isEmpty()) {
            throw new IllegalArgumentException("Named strategy label missing unstable token: " + label);
        }

        String unstableToken = encodedTokens.get(encodedTokens.size() - 1);
        if (!unstableToken.startsWith("u")) {
            throw new IllegalArgumentException("Unstable token must start with 'u': " + unstableToken);
        }

        int labelUnstable;
        try {
            labelUnstable = Integer.parseInt(unstableToken.substring(1));
        } catch (NumberFormatException ex) {
            throw new IllegalArgumentException("Invalid unstable token: " + unstableToken, ex);
        }

        List<String> labelArguments = encodedTokens.subList(0, encodedTokens.size() - 1);

        Map<String, Object> parameters = descriptor.getParameters();
        List<String> descriptorArgs = extractArgumentList(parameters.get("args"));
        int descriptorUnstable = extractUnstableBars(parameters.get("unstableBars"));

        if (descriptorUnstable != labelUnstable) {
            throw new IllegalArgumentException("Unstable bar mismatch between label and descriptor: " + labelUnstable
                    + " vs " + descriptorUnstable);
        }

        List<String> constructorArguments;
        if (!descriptorArgs.isEmpty()) {
            if (descriptorArgs.size() != labelArguments.size()) {
                throw new IllegalArgumentException("Named strategy argument count mismatch: " + descriptorArgs.size()
                        + " vs " + labelArguments.size());
            }
            if (!labelArguments.isEmpty() && !descriptorArgs.equals(labelArguments)) {
                throw new IllegalArgumentException(
                        "Named strategy argument tokens mismatch between label and descriptor");
            }
            constructorArguments = descriptorArgs;
        } else {
            constructorArguments = labelArguments;
        }

        List<String> tokens = new ArrayList<>(constructorArguments.size() + 1);
        tokens.addAll(constructorArguments);
        tokens.add(Integer.toString(descriptorUnstable));

        Constructor<? extends Strategy> constructor = findNamedStrategyConstructor(strategyType);
        try {
            return constructor.newInstance(series, tokens.toArray(new String[0]));
        } catch (InstantiationException | IllegalAccessException ex) {
            throw new IllegalStateException("Failed to construct named strategy: " + strategyType.getName(), ex);
        } catch (InvocationTargetException ex) {
            Throwable cause = ex.getCause();
            if (cause instanceof IllegalArgumentException) {
                throw (IllegalArgumentException) cause;
            }
            throw new IllegalStateException("Failed to construct named strategy: " + strategyType.getName(), cause);
        }
    }

    private static Constructor<? extends Strategy> findNamedStrategyConstructor(
            Class<? extends Strategy> strategyType) {
        try {
            Constructor<? extends Strategy> constructor = strategyType.getDeclaredConstructor(BarSeries.class,
                    String[].class);
            constructor.setAccessible(true);
            return constructor;
        } catch (NoSuchMethodException ex) {
            throw new IllegalStateException(
                    "Named strategy missing (BarSeries, String...) constructor: " + strategyType.getName(), ex);
        }
    }

    private static List<String> parseLabelTokens(String label, String simpleName) {
        if (label.length() == simpleName.length()) {
            return Collections.singletonList("u0");
        }
        int separatorIndex = simpleName.length();
        if (label.charAt(separatorIndex) != '_') {
            throw new IllegalArgumentException("Named strategy label missing separator: " + label);
        }
        String remainder = label.substring(separatorIndex + 1);
        if (remainder.isEmpty()) {
            return Collections.singletonList("u0");
        }
        return Arrays.asList(remainder.split("_"));
    }

    private static List<String> extractArgumentList(Object raw) {
        if (raw == null) {
            return Collections.emptyList();
        }
        if (raw instanceof List<?>) {
            List<?> list = (List<?>) raw;
            List<String> arguments = new ArrayList<>(list.size());
            for (Object element : list) {
                arguments.add(String.valueOf(element));
            }
            return arguments;
        }
        return Collections.singletonList(String.valueOf(raw));
    }
}
