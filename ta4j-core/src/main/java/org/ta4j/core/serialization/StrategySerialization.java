/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2017-2025 Ta4j Organization & respective
 * authors (see AUTHORS)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package org.ta4j.core.serialization;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import org.ta4j.core.BarSeries;
import org.ta4j.core.BaseStrategy;
import org.ta4j.core.Rule;
import org.ta4j.core.Strategy;

/**
 * Serializes and deserializes {@link Strategy} instances into structured
 * {@link ComponentDescriptor} payloads.
 *
 * @since 0.19
 */
public final class StrategySerialization {

    private static final String ENTRY_LABEL = "entry";
    private static final String EXIT_LABEL = "exit";
    private static final String STRATEGY_PACKAGE = "org.ta4j.core";

    private StrategySerialization() {
    }

    /**
     * Serializes a {@link Strategy} to a JSON payload.
     *
     * @param strategy strategy instance
     * @return JSON representation
     */
    public static String toJson(Strategy strategy) {
        return ComponentSerialization.toJson(describe(strategy));
    }

    /**
     * Converts a {@link Strategy} into a {@link ComponentDescriptor} hierarchy.
     *
     * @param strategy strategy instance
     * @return descriptor representing the strategy
     */
    public static ComponentDescriptor describe(Strategy strategy) {
        Objects.requireNonNull(strategy, "strategy");

        ComponentDescriptor entryDescriptor = ComponentSerialization.parse(strategy.getEntryRule().getName());
        ComponentDescriptor exitDescriptor = ComponentSerialization.parse(strategy.getExitRule().getName());

        ComponentDescriptor.Builder builder = ComponentDescriptor.builder()
                .withType(strategy.getClass().getSimpleName());

        String name = strategy.getName();
        if (name != null && !name.isBlank()) {
            builder.withLabel(name);
        }

        Map<String, Object> parameters = new HashMap<>();
        parameters.put("unstableBars", strategy.getUnstableBars());
        builder.withParameters(parameters);

        if (entryDescriptor != null) {
            builder.addChild(applyLabel(entryDescriptor, ENTRY_LABEL));
        }
        if (exitDescriptor != null) {
            builder.addChild(applyLabel(exitDescriptor, EXIT_LABEL));
        }

        return builder.build();
    }

    /**
     * Rebuilds a strategy from a JSON payload.
     *
     * @param series bar series to attach to the strategy
     * @param json   JSON representation generated by {@link #toJson(Strategy)}
     * @return reconstructed strategy
     */
    public static Strategy fromJson(BarSeries series, String json) {
        ComponentDescriptor descriptor = ComponentSerialization.parse(json);
        return fromDescriptor(series, descriptor);
    }

    /**
     * Rebuilds a strategy from a descriptor tree.
     *
     * @param series     bar series to attach to the strategy
     * @param descriptor descriptor describing the strategy
     * @return reconstructed strategy
     */
    public static Strategy fromDescriptor(BarSeries series, ComponentDescriptor descriptor) {
        Objects.requireNonNull(series, "series");
        Objects.requireNonNull(descriptor, "descriptor");

        Rule entryRule = instantiateRule(series, extractChild(descriptor, ENTRY_LABEL));
        Rule exitRule = instantiateRule(series, extractChild(descriptor, EXIT_LABEL));

        String name = descriptor.getLabel();
        int unstableBars = extractUnstableBars(descriptor.getParameters().get("unstableBars"));

        Class<? extends Strategy> strategyType = resolveStrategyClass(descriptor.getType());
        Strategy strategy = instantiateStrategy(strategyType, name, entryRule, exitRule, unstableBars);
        strategy.setUnstableBars(unstableBars);
        return strategy;
    }

    private static ComponentDescriptor applyLabel(ComponentDescriptor descriptor, String label) {
        if (descriptor == null) {
            return null;
        }
        ComponentDescriptor.Builder builder = ComponentDescriptor.builder()
                .withType(descriptor.getType())
                .withLabel(label);
        if (!descriptor.getParameters().isEmpty()) {
            builder.withParameters(descriptor.getParameters());
        }
        for (ComponentDescriptor child : descriptor.getChildren()) {
            builder.addChild(child);
        }
        return builder.build();
    }

    private static ComponentDescriptor extractChild(ComponentDescriptor descriptor, String label) {
        for (ComponentDescriptor child : descriptor.getChildren()) {
            if (label.equals(child.getLabel())) {
                return cloneWithoutLabel(child);
            }
        }
        throw new IllegalArgumentException("Missing strategy " + label + " rule descriptor");
    }

    private static ComponentDescriptor cloneWithoutLabel(ComponentDescriptor descriptor) {
        if (descriptor == null) {
            return null;
        }
        ComponentDescriptor.Builder builder = ComponentDescriptor.builder().withType(descriptor.getType());
        if (!descriptor.getParameters().isEmpty()) {
            builder.withParameters(descriptor.getParameters());
        }
        for (ComponentDescriptor child : descriptor.getChildren()) {
            builder.addChild(child);
        }
        return builder.build();
    }

    private static int extractUnstableBars(Object value) {
        if (value == null) {
            return 0;
        }
        if (value instanceof Number) {
            return ((Number) value).intValue();
        }
        return Integer.parseInt(String.valueOf(value));
    }

    private static Rule instantiateRule(BarSeries series, ComponentDescriptor descriptor) {
        if (descriptor == null) {
            throw new IllegalArgumentException("Rule descriptor cannot be null");
        }
        String type = descriptor.getType();
        if (type == null || type.isBlank()) {
            throw new IllegalArgumentException("Rule descriptor missing type: " + descriptor);
        }
        Class<?> clazz = resolveRuleClass(type);
        if (!Rule.class.isAssignableFrom(clazz)) {
            throw new IllegalArgumentException("Descriptor type does not implement Rule: " + type);
        }
        @SuppressWarnings("unchecked")
        Class<? extends Rule> ruleType = (Class<? extends Rule>) clazz;

        Optional<Rule> instance = invokeFactory(ruleType, series, descriptor);
        if (instance.isPresent()) {
            return instance.get();
        }

        if (!descriptor.getChildren().isEmpty()) {
            List<Rule> children = new ArrayList<>(descriptor.getChildren().size());
            for (ComponentDescriptor child : descriptor.getChildren()) {
                children.add(instantiateRule(series, child));
            }
            Optional<Rule> composite = tryCompositeConstructor(ruleType, children);
            if (composite.isPresent()) {
                return composite.get();
            }
        }

        Optional<Rule> constructed = tryDescriptorConstructor(ruleType, series, descriptor);
        if (constructed.isPresent()) {
            return constructed.get();
        }

        throw new IllegalArgumentException("Unable to instantiate rule type: " + type);
    }

    private static Optional<Rule> invokeFactory(Class<? extends Rule> ruleType, BarSeries series,
            ComponentDescriptor descriptor) {
        try {
            Method factory = ruleType.getDeclaredMethod("fromDescriptor", BarSeries.class, ComponentDescriptor.class);
            factory.setAccessible(true);
            return Optional.of((Rule) factory.invoke(null, series, descriptor));
        } catch (NoSuchMethodException ex) {
            // ignore and try the next option
        } catch (IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to invoke factory on rule type: " + ruleType.getName(), ex);
        }

        try {
            Method factory = ruleType.getDeclaredMethod("fromDescriptor", ComponentDescriptor.class);
            factory.setAccessible(true);
            return Optional.of((Rule) factory.invoke(null, descriptor));
        } catch (NoSuchMethodException ex) {
            // ignore and try next
        } catch (IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to invoke factory on rule type: " + ruleType.getName(), ex);
        }

        return Optional.empty();
    }

    private static Optional<Rule> tryCompositeConstructor(Class<? extends Rule> ruleType, List<Rule> children) {
        Constructor<?>[] constructors = ruleType.getDeclaredConstructors();
        for (Constructor<?> constructor : constructors) {
            Class<?>[] parameterTypes = constructor.getParameterTypes();
            if (parameterTypes.length != children.size()) {
                continue;
            }
            boolean matches = true;
            for (Class<?> parameterType : parameterTypes) {
                if (!Rule.class.isAssignableFrom(parameterType)) {
                    matches = false;
                    break;
                }
            }
            if (!matches) {
                continue;
            }
            try {
                constructor.setAccessible(true);
                return Optional.of((Rule) constructor.newInstance(children.toArray()));
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                throw new IllegalStateException("Failed to construct composite rule: " + ruleType.getName(), ex);
            }
        }
        return Optional.empty();
    }

    private static Optional<Rule> tryDescriptorConstructor(Class<? extends Rule> ruleType, BarSeries series,
            ComponentDescriptor descriptor) {
        try {
            Constructor<? extends Rule> constructor = ruleType.getDeclaredConstructor(BarSeries.class,
                    ComponentDescriptor.class);
            constructor.setAccessible(true);
            return Optional.of(constructor.newInstance(series, descriptor));
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct rule: " + ruleType.getName(), ex);
        }

        try {
            Constructor<? extends Rule> constructor = ruleType.getDeclaredConstructor(ComponentDescriptor.class);
            constructor.setAccessible(true);
            return Optional.of(constructor.newInstance(descriptor));
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct rule: " + ruleType.getName(), ex);
        }

        try {
            Constructor<? extends Rule> constructor = ruleType.getDeclaredConstructor();
            constructor.setAccessible(true);
            return Optional.of(constructor.newInstance());
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct rule: " + ruleType.getName(), ex);
        }

        return Optional.empty();
    }

    @SuppressWarnings("unchecked")
    private static Class<? extends Rule> resolveRuleClass(String type) {
        try {
            return (Class<? extends Rule>) Class.forName(type);
        } catch (ClassNotFoundException ex) {
            // try ta4j core rules package
        }
        try {
            return (Class<? extends Rule>) Class.forName("org.ta4j.core.rules." + type);
        } catch (ClassNotFoundException ex) {
            throw new IllegalArgumentException("Unknown rule type: " + type, ex);
        }
    }

    @SuppressWarnings("unchecked")
    private static Class<? extends Strategy> resolveStrategyClass(String type) {
        if (type == null || type.isBlank()) {
            return BaseStrategy.class;
        }
        try {
            Class<?> clazz = Class.forName(type);
            if (Strategy.class.isAssignableFrom(clazz)) {
                return (Class<? extends Strategy>) clazz;
            }
        } catch (ClassNotFoundException ex) {
            // ignore and try package-local lookup
        }
        try {
            Class<?> clazz = Class.forName(STRATEGY_PACKAGE + '.' + type);
            if (Strategy.class.isAssignableFrom(clazz)) {
                return (Class<? extends Strategy>) clazz;
            }
        } catch (ClassNotFoundException ex) {
            // ignore and fall back to BaseStrategy
        }
        return BaseStrategy.class;
    }

    private static Strategy instantiateStrategy(Class<? extends Strategy> strategyType, String name, Rule entryRule,
            Rule exitRule, int unstableBars) {
        try {
            Constructor<? extends Strategy> constructor = strategyType.getDeclaredConstructor(String.class, Rule.class,
                    Rule.class, int.class);
            constructor.setAccessible(true);
            return constructor.newInstance(name, entryRule, exitRule, unstableBars);
        } catch (NoSuchMethodException ex) {
            // ignore and try the next options
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct strategy: " + strategyType.getName(), ex);
        }

        try {
            Constructor<? extends Strategy> constructor = strategyType.getDeclaredConstructor(String.class, Rule.class,
                    Rule.class);
            constructor.setAccessible(true);
            Strategy strategy = constructor.newInstance(name, entryRule, exitRule);
            strategy.setUnstableBars(unstableBars);
            return strategy;
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct strategy: " + strategyType.getName(), ex);
        }

        try {
            Constructor<? extends Strategy> constructor = strategyType.getDeclaredConstructor(Rule.class, Rule.class,
                    int.class);
            constructor.setAccessible(true);
            Strategy strategy = constructor.newInstance(entryRule, exitRule, unstableBars);
            return strategy;
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct strategy: " + strategyType.getName(), ex);
        }

        try {
            Constructor<? extends Strategy> constructor = strategyType.getDeclaredConstructor(Rule.class, Rule.class);
            constructor.setAccessible(true);
            Strategy strategy = constructor.newInstance(entryRule, exitRule);
            strategy.setUnstableBars(unstableBars);
            return strategy;
        } catch (NoSuchMethodException ex) {
            // ignore
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
            throw new IllegalStateException("Failed to construct strategy: " + strategyType.getName(), ex);
        }

        if (!strategyType.equals(BaseStrategy.class)) {
            return new BaseStrategy(name, entryRule, exitRule, unstableBars);
        }
        throw new IllegalStateException("No suitable constructor found for strategy type: " + strategyType.getName());
    }
}
