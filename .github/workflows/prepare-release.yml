name: Prepare Release

concurrency:
  group: prepare-release-${{ github.repository }}
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      releaseVersion:
        description: "OPTIONAL: Release version (e.g. 0.20.0). Leave blank to auto-detect."
        required: false
      nextVersion:
        description: "OPTIONAL: Next snapshot version (e.g. 0.20.1-SNAPSHOT). Leave blank to auto-generate."
        required: false
      dryRun:
        description: "Run prepare workflow in dry-run mode (no push or PR creation)."
        required: false
        default: false
        type: boolean

permissions:
  actions: write
  contents: write
  pull-requests: write

jobs:
  prepare:
    name: Prepare Release
    runs-on: ubuntu-latest

    steps:
      # -----------------------
      # Setup and Validation
      # -----------------------
      - name: Normalize dry run input
        id: dry_run
        run: |
          raw="${{ github.event.inputs.dryRun }}"
          normalized=$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]')

          if [ "$normalized" = "true" ] || [ "$raw" = "true" ] || [ "$raw" = true ] || [ "$raw" = "1" ]; then
            dry_run=true
          else
            dry_run=false
          fi

          echo "audit:dry_run_input_raw='${raw}'"
          echo "audit:dry_run_normalized=$dry_run"
          echo "dryRun=$dry_run" >> $GITHUB_OUTPUT

      - name: Normalize direct push flag
        id: direct_push
        env:
          DIRECT_PUSH: ${{ vars.RELEASE_DIRECT_PUSH }}
        run: |
          raw="${DIRECT_PUSH:-}"
          normalized=$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]')

          if [ "$normalized" = "true" ] || [ "$normalized" = "1" ] || [ "$normalized" = "yes" ]; then
            enabled=true
          else
            enabled=false
          fi

          echo "audit:release_direct_push=$enabled raw='${raw}'"
          echo "enabled=$enabled" >> $GITHUB_OUTPUT

      - name: Preflight GH_TA4J_REPO_TOKEN permissions
        id: token_preflight
        env:
          GH_TA4J_REPO_TOKEN: ${{ secrets.GH_TA4J_REPO_TOKEN }}
          DRY_RUN: ${{ steps.dry_run.outputs.dryRun }}
          DIRECT_PUSH: ${{ steps.direct_push.outputs.enabled }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json
          import os
          import sys
          import urllib.request

          token = os.environ.get("GH_TA4J_REPO_TOKEN", "")
          dry_run = os.environ.get("DRY_RUN", "false").lower() == "true"
          direct_push = os.environ.get("DIRECT_PUSH", "false").lower() == "true"

          output_path = os.environ.get("GITHUB_OUTPUT")
          def write_output(line: str) -> None:
              if output_path:
                  with open(output_path, "a", encoding="utf-8") as fh:
                      fh.write(line + "\n")

          def warn_or_error(message: str) -> bool:
              if dry_run:
                  print(f"::warning::{message}")
                  return False
              if direct_push:
                  print(f"::error::{message}")
                  return True
              print(f"::warning::{message}")
              return False

          if not token:
              print("audit:repo_token_present=false")
              write_output("repo_token_present=false")
              write_output("use_repo_token=false")
              sys.exit(0)

          owner = os.environ.get("GITHUB_REPOSITORY_OWNER")
          repo = os.environ.get("GITHUB_REPOSITORY", "").split("/", 1)[-1]
          if not owner or not repo:
              print("::error::Unable to resolve repository context for permission preflight.")
              sys.exit(1)

          def request_json(url: str, payload=None):
              headers = {
                  "Authorization": f"Bearer {token}",
                  "User-Agent": "ta4j-release-preflight",
                  "Accept": "application/vnd.github+json",
              }
              data = None
              if payload is not None:
                  headers["Content-Type"] = "application/json"
                  data = json.dumps(payload).encode("utf-8")
              req = urllib.request.Request(url, data=data, headers=headers)
              with urllib.request.urlopen(req) as resp:
                  body = json.load(resp)
                  response_headers = {k.lower(): v for k, v in resp.headers.items()}
              return body, response_headers

          query = {
              "query": "query($owner:String!,$repo:String!){repository(owner:$owner,name:$repo){viewerPermission}}",
              "variables": {"owner": owner, "repo": repo},
          }
          try:
              graphql_data, _ = request_json("https://api.github.com/graphql", query)
              repo_data, repo_headers = request_json(f"https://api.github.com/repos/{owner}/{repo}")
          except Exception as exc:
              msg = f"GH_TA4J_REPO_TOKEN permission check failed: {exc}"
              should_fail = warn_or_error(msg)
              write_output("repo_token_present=true")
              write_output("use_repo_token=false")
              if should_fail:
                  sys.exit(1)
              sys.exit(0)

          if "errors" in graphql_data:
              msg = f"GH_TA4J_REPO_TOKEN permission check failed: {graphql_data['errors']}"
              should_fail = warn_or_error(msg)
              write_output("repo_token_present=true")
              write_output("use_repo_token=false")
              if should_fail:
                  sys.exit(1)
              sys.exit(0)

          permission = graphql_data.get("data", {}).get("repository", {}).get("viewerPermission")
          push_permission = bool(repo_data.get("permissions", {}).get("push"))
          scopes_header = repo_headers.get("x-oauth-scopes", "")
          scopes = [scope.strip() for scope in scopes_header.split(",") if scope.strip()]
          has_repo_scope = any(scope == "repo" or scope.startswith("repo:") for scope in scopes)
          has_public_repo_scope = "public_repo" in scopes
          scope_check = "unknown"
          scope_allows_push = True
          if scopes:
              scope_check = "pass" if (has_repo_scope or has_public_repo_scope) else "fail"
              scope_allows_push = scope_check == "pass"

          permission_allows_push = permission in ("WRITE", "MAINTAIN", "ADMIN") or push_permission
          allowed = permission_allows_push and scope_allows_push

          write_output("repo_token_present=true")
          write_output(f"repo_token_permission={permission}")
          write_output(f"repo_token_push_permission={'true' if push_permission else 'false'}")
          write_output(f"repo_token_scope_check={scope_check}")
          write_output(f"use_repo_token={'true' if allowed else 'false'}")

          if not allowed:
              reasons = []
              if not permission_allows_push:
                  reasons.append(
                      f"viewerPermission={permission}, permissions.push={'true' if push_permission else 'false'}"
                  )
              if not scope_allows_push:
                  reasons.append(f"oauth_scopes='{scopes_header}'")
              reason_text = "; ".join(reasons) if reasons else "unknown policy mismatch"
              msg = f"GH_TA4J_REPO_TOKEN lacks push capability ({reason_text})."
              should_fail = warn_or_error(msg)
              if should_fail:
                  sys.exit(1)
              sys.exit(0)

          print(f"audit:repo_token_permission={permission}")
          print(f"audit:repo_token_push_permission={'true' if push_permission else 'false'}")
          print(f"audit:repo_token_scope_check={scope_check}")
          print("audit:repo_token_usable=true")
          PY

      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: true
          token: ${{ steps.token_preflight.outputs.use_repo_token == 'true' && secrets.GH_TA4J_REPO_TOKEN || github.token }}

      # -----------------------
      # Version Detection
      # -----------------------
      - name: Read current version from POM
        id: read_current
        shell: bash
        run: |
          CURRENT=$(mvn -q -DforceStdout help:evaluate -Dexpression=project.version)
          echo "Detected project.version: $CURRENT"

          if [[ -z "${CURRENT}" ]]; then
            echo "Error: Failed to read project.version from pom.xml"
            exit 1
          fi

          echo "current=$CURRENT" >> $GITHUB_OUTPUT

      - name: Capture user input versions
        id: user_input
        env:
          INPUT_RELEASE: ${{ github.event.inputs.releaseVersion }}
          INPUT_NEXT: ${{ github.event.inputs.nextVersion }}
        run: |
          echo "Inputs: release='${INPUT_RELEASE}', next='${INPUT_NEXT}'"
          echo "release_input=${INPUT_RELEASE:-}" >> $GITHUB_OUTPUT
          echo "next_input=${INPUT_NEXT:-}" >> $GITHUB_OUTPUT

      - name: Determine release version
        id: determine_release
        shell: bash
        env:
          CURRENT: ${{ steps.read_current.outputs.current }}
          INPUT_RELEASE: ${{ steps.user_input.outputs.release_input }}
        run: |
          set -euo pipefail

          if [[ -z "${INPUT_RELEASE}" ]]; then
            if [[ "${CURRENT}" != *-SNAPSHOT ]]; then
              echo "Error: Current version '${CURRENT}' is not a SNAPSHOT version."
              echo "Cannot auto-detect release version from a non-SNAPSHOT version."
              echo "Please provide an explicit releaseVersion input or ensure the POM contains a SNAPSHOT version."
              exit 1
            fi
            RELEASE="${CURRENT%-SNAPSHOT}"
            echo "Auto-detected release version: ${RELEASE} (from ${CURRENT})"
          else
            RELEASE="${INPUT_RELEASE}"
          fi

          if [[ "${RELEASE}" == *-SNAPSHOT* ]]; then
            echo "Error: releaseVersion must be a stable version (no -SNAPSHOT suffix). Got: ${RELEASE}"
            exit 1
          fi

          if [[ ! "${RELEASE}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: releaseVersion must be major.minor.patch (e.g. 0.20.0). Got: ${RELEASE}"
            exit 1
          fi

          if [[ "${CURRENT}" == *-SNAPSHOT ]]; then
            CURRENT_BASE="${CURRENT%-SNAPSHOT}"
          else
            CURRENT_BASE="${CURRENT}"
          fi

          if [[ -z "${CURRENT_BASE}" ]]; then
            echo "Error: unable to determine current base version from pom.xml"
            exit 1
          fi

          if [[ "$(printf '%s\n' "${CURRENT_BASE}" "${RELEASE}" | sort -V | head -n1)" != "${CURRENT_BASE}" ]]; then
            echo "Error: releaseVersion (${RELEASE}) is lower than the current pom.xml version (${CURRENT_BASE})."
            echo "Refusing to release a version lower than the POM."
            exit 1
          fi

          echo "release=$RELEASE" >> $GITHUB_OUTPUT

      - name: Determine next snapshot version
        id: determine_next
        shell: bash
        env:
          RELEASE: ${{ steps.determine_release.outputs.release }}
          INPUT_NEXT: ${{ steps.user_input.outputs.next_input }}
        run: |
          set -euo pipefail

          if [[ -z "${INPUT_NEXT}" ]]; then
            BASE="${RELEASE}"
            if [[ "${BASE}" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              MAJOR="${BASH_REMATCH[1]}"
              MINOR="${BASH_REMATCH[2]}"
              PATCH="${BASH_REMATCH[3]}"
              NEXT="${MAJOR}.${MINOR}.$((PATCH+1))-SNAPSHOT"
            else
              echo "Error: Unsupported release version format '${BASE}'. Expected major.minor.patch"
              exit 1
            fi
          else
            NEXT="${INPUT_NEXT}"
          fi

          if [[ "${NEXT}" != *-SNAPSHOT ]]; then
            echo "Error: nextVersion must end with -SNAPSHOT. Got: ${NEXT}"
            exit 1
          fi

          if [[ ! "${NEXT}" =~ ^[0-9]+\.[0-9]+\.[0-9]+-SNAPSHOT$ ]]; then
            echo "Error: nextVersion must be major.minor.patch-SNAPSHOT (e.g. 0.20.1-SNAPSHOT). Got: ${NEXT}"
            exit 1
          fi

          NEXT_BASE="${NEXT%-SNAPSHOT}"
          # Verify that nextVersion is actually greater than releaseVersion
          highest=$(printf '%s\n' "${RELEASE}" "${NEXT_BASE}" | sort -V | tail -n1)
          if [[ "${highest}" != "${NEXT_BASE}" ]] || [[ "${NEXT_BASE}" == "${RELEASE}" ]]; then
            echo "Error: nextVersion (${NEXT_BASE}) must be greater than releaseVersion (${RELEASE})"
            exit 1
          fi

          echo "next=$NEXT" >> $GITHUB_OUTPUT

      - name: Export version outputs
        id: versions
        shell: bash
        env:
          RELEASE: ${{ steps.determine_release.outputs.release }}
          NEXT: ${{ steps.determine_next.outputs.next }}
          CURRENT: ${{ steps.read_current.outputs.current }}
        run: |
          echo "Using release: $RELEASE"
          echo "Using next snapshot: $NEXT"
          echo "release=$RELEASE" >> $GITHUB_OUTPUT
          echo "next=$NEXT" >> $GITHUB_OUTPUT
          echo "current=$CURRENT" >> $GITHUB_OUTPUT

      - name: Preflight git push capability
        if: steps.dry_run.outputs.dryRun != 'true'
        env:
          DIRECT_PUSH: ${{ steps.direct_push.outputs.enabled }}
          TARGET_BRANCH: ${{ github.event.repository.default_branch }}
          RELEASE_BRANCH: release/${{ steps.versions.outputs.release }}
          USE_REPO_TOKEN: ${{ steps.token_preflight.outputs.use_repo_token }}
        run: |
          set -euo pipefail
          if [ "${DIRECT_PUSH}" = "true" ]; then
            if [ -z "${TARGET_BRANCH:-}" ]; then
              echo "Default branch was not set; refusing to probe push capability."
              exit 1
            fi
            refspec="HEAD:refs/heads/${TARGET_BRANCH}"
            mode="default-branch"
          else
            refspec="HEAD:refs/heads/${RELEASE_BRANCH}"
            mode="release-branch"
          fi

          echo "audit:push_probe_mode=${mode} refspec=${refspec} use_repo_token=${USE_REPO_TOKEN:-false}"

          set +e
          if [ "${DIRECT_PUSH}" = "true" ]; then
            output=$(git push --dry-run origin "${refspec}" 2>&1)
          else
            output=$(git push --dry-run --force-with-lease origin "${refspec}" 2>&1)
          fi
          status=$?
          set -e

          printf '%s\n' "$output"

          if [ "$status" -ne 0 ]; then
            echo "::error::Push capability probe failed for ${mode}. Check token/repository permissions."
            exit "$status"
          fi

      # -----------------------
      # Release Preparation
      # -----------------------
      - name: Dry-run mode notice
        if: steps.dry_run.outputs.dryRun == 'true'
        run: |
          echo "DRY RUN ENABLED: skipping commits, push, and PR creation."

      - name: Prepare Release Notes
        run: |
          chmod +x scripts/prepare-release.sh
          scripts/prepare-release.sh "${{ steps.versions.outputs.release }}"

      - name: Configure git user
        if: steps.dry_run.outputs.dryRun != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # -----------------------
      # Apply Release Version
      # -----------------------
      - name: Set Maven version to release
        if: steps.dry_run.outputs.dryRun != 'true'
        env:
          RELEASE_VERSION: ${{ steps.versions.outputs.release }}
        run: |
          mvn -B versions:set -DnewVersion=$RELEASE_VERSION

      - name: Commit Maven version change
        if: steps.dry_run.outputs.dryRun != 'true'
        run: |
          mvn -B versions:commit

      - name: Commit release version and notes
        if: steps.dry_run.outputs.dryRun != 'true'
        run: |
          git add release/${{ steps.versions.outputs.release }}.md
          git add -u
          git commit -am "Release ${{ steps.versions.outputs.release }}"

      - name: Capture release commit
        id: release_commit
        if: steps.dry_run.outputs.dryRun != 'true'
        run: |
          sha=$(git rev-parse HEAD)
          echo "release_commit=$sha" >> $GITHUB_OUTPUT

      # -----------------------
      # Apply Next Snapshot Version
      # -----------------------
      - name: Set Maven version to next snapshot
        if: steps.dry_run.outputs.dryRun != 'true'
        env:
          NEXT_VERSION: ${{ steps.versions.outputs.next }}
        run: |
          mvn -B versions:set -DnewVersion=$NEXT_VERSION

      - name: Commit Maven version change for next
        if: steps.dry_run.outputs.dryRun != 'true'
        run: |
          mvn -B versions:commit

      - name: Commit next snapshot version
        if: steps.dry_run.outputs.dryRun != 'true'
        run: |
          git commit -am "Start ${{ steps.versions.outputs.next }}"

      # -----------------------
      # Push or PR
      # -----------------------
      - name: Push release commits directly to default branch
        if: steps.dry_run.outputs.dryRun != 'true' && steps.direct_push.outputs.enabled == 'true'
        env:
          TARGET_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail
          branch="${TARGET_BRANCH:-}"
          if [ -z "$branch" ]; then
            echo "Default branch was not set; refusing to push."
            exit 1
          fi
          git fetch origin "${branch}"
          if ! git merge-base --is-ancestor "origin/${branch}" HEAD; then
            echo "Default branch '${branch}' advanced after preparation; refusing to push."
            exit 1
          fi
          echo "Pushing release commits directly to ${branch}."
          git push origin "HEAD:${branch}"

      - name: Dispatch publish-release workflow (direct push)
        if: steps.dry_run.outputs.dryRun != 'true' && steps.direct_push.outputs.enabled == 'true'
        uses: actions/github-script@v8
        env:
          RELEASE_VERSION: ${{ steps.versions.outputs.release }}
          RELEASE_COMMIT: ${{ steps.release_commit.outputs.release_commit }}
          DRY_RUN: ${{ steps.dry_run.outputs.dryRun }}
        with:
          github-token: ${{ steps.token_preflight.outputs.use_repo_token == 'true' && secrets.GH_TA4J_REPO_TOKEN || github.token }}
          script: |
            const releaseVersion = process.env.RELEASE_VERSION;
            const releaseCommit = process.env.RELEASE_COMMIT;
            const dryRun = process.env.DRY_RUN || "false";
            if (!releaseVersion || !releaseCommit) {
              throw new Error("Missing release version or release commit for publish dispatch.");
            }
            const ref = "${{ github.event.repository.default_branch }}";
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: "publish-release.yml",
              ref,
              inputs: {
                releaseVersion,
                releaseCommit,
                dryRun
              }
            });

      - name: Create release branch
        if: steps.dry_run.outputs.dryRun != 'true' && steps.direct_push.outputs.enabled != 'true'
        env:
          RELEASE_BRANCH: release/${{ steps.versions.outputs.release }}
        run: |
          git checkout -b "${RELEASE_BRANCH}"

      - name: Push release branch
        if: steps.dry_run.outputs.dryRun != 'true' && steps.direct_push.outputs.enabled != 'true'
        env:
          RELEASE_BRANCH: release/${{ steps.versions.outputs.release }}
        run: |
          git push --force-with-lease origin "HEAD:refs/heads/${RELEASE_BRANCH}"

      - name: Create or update release PR
        if: steps.dry_run.outputs.dryRun != 'true' && steps.direct_push.outputs.enabled != 'true'
        uses: actions/github-script@v8
        env:
          RELEASE_VERSION: ${{ steps.versions.outputs.release }}
          NEXT_VERSION: ${{ steps.versions.outputs.next }}
          RELEASE_COMMIT: ${{ steps.release_commit.outputs.release_commit }}
          RELEASE_BRANCH: release/${{ steps.versions.outputs.release }}
          TARGET_BRANCH: ${{ github.event.repository.default_branch }}
        with:
          github-token: ${{ steps.token_preflight.outputs.use_repo_token == 'true' && secrets.GH_TA4J_REPO_TOKEN || github.token }}
          script: |
            const releaseVersion = process.env.RELEASE_VERSION;
            const nextVersion = process.env.NEXT_VERSION;
            const releaseCommit = process.env.RELEASE_COMMIT;
            const releaseBranch = process.env.RELEASE_BRANCH;
            const baseBranch = process.env.TARGET_BRANCH;

            if (!releaseVersion || !nextVersion || !releaseCommit || !releaseBranch || !baseBranch) {
              throw new Error("Missing required release metadata for PR creation.");
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = `${owner}:${releaseBranch}`;

            const body = [
              `Automated release PR for ${releaseVersion}.`,
              "",
              "Contains:",
              `- Set version to ${releaseVersion}`,
              `- Generated release notes: release/${releaseVersion}.md`,
              `- Bump to next snapshot: ${nextVersion}`,
              "",
              "<!-- release-meta",
              `releaseVersion: ${releaseVersion}`,
              `nextVersion: ${nextVersion}`,
              `releaseCommit: ${releaseCommit}`,
              "-->"
            ].join("\n");

            const existing = await github.rest.pulls.list({
              owner,
              repo,
              state: "open",
              head
            });

            let prNumber;
            if (existing.data.length > 0) {
              const pr = existing.data[0];
              prNumber = pr.number;
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: pr.number,
                title: `Release ${releaseVersion}`,
                base: baseBranch,
                body
              });
            } else {
              const created = await github.rest.pulls.create({
                owner,
                repo,
                title: `Release ${releaseVersion}`,
                head: releaseBranch,
                base: baseBranch,
                body
              });
              prNumber = created.data.number;
            }

            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: ["release"]
              });
            } catch (error) {
              console.warn(`Failed to add release label: ${error.message}`);
            }

      # -----------------------
      # Summary
      # -----------------------
      - name: Prepare release summary
        if: always()
        env:
          DRY_RUN: ${{ steps.dry_run.outputs.dryRun }}
          DIRECT_PUSH: ${{ steps.direct_push.outputs.enabled }}
          RELEASE: ${{ steps.versions.outputs.release }}
          NEXT: ${{ steps.versions.outputs.next }}
          CURRENT: ${{ steps.versions.outputs.current }}
          RELEASE_COMMIT: ${{ steps.release_commit.outputs.release_commit }}
        run: |
          echo "summary: dryRun=${DRY_RUN:-}"
          echo "summary: directPush=${DIRECT_PUSH:-}"
          echo "summary: release=${RELEASE:-}"
          echo "summary: current=${CURRENT:-}"
          echo "summary: next=${NEXT:-}"
          echo "summary: releaseCommit=${RELEASE_COMMIT:-}"
